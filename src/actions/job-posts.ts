'use server'

import { revalidatePath } from 'next/cache'
import { createClient } from '@/lib/supabase/server'
import { verifySession, requirePermission } from '@/lib/dal'
import { Permissions } from '@/lib/permission-constants'
import { createAuditLog, AUDIT_ACTION_TYPES } from '@/lib/audit'
import type {
  JobPost,
  JobPostFormData,
  GetJobPostsParams,
  JobPostWithUsers,
} from '@/types/job-posts'
import {
  splitByNewline,
  canPublishPost,
  isValidEmail,
} from '@/lib/job-posts/posts'

type ActionResponse<T = unknown> =
  | { success: true; data: T; message?: string }
  | { success: false; error: string }

/**
 * Get paginated job posts with filters
 */
export async function getJobPostsAction(params: GetJobPostsParams = {}): Promise<
  ActionResponse<{
    posts: JobPostWithUsers[]
    total: number
    page: number
    pages: number
  }>
> {
  try {
    await verifySession()
    await requirePermission(Permissions.JOB_POSTS_VIEW)

    const supabase = await createClient()
    const page = params.page || 1
    const limit = params.limit || 10
    const offset = (page - 1) * limit

    let query = supabase
      .from('job_posts')
      .select(
        `
        *,
        category:job_categories(id, name),
        creator:created_by(name, email),
        updater:updated_by(name, email),
        publisher:published_by(name, email)
      `,
        { count: 'exact' }
      )
      .order('created_at', { ascending: false })

    if (params.search) {
      query = query.or(`title.ilike.%${params.search}%,description.ilike.%${params.search}%`)
    }

    if (params.status) query = query.eq('status', params.status)
    if (params.category) query = query.eq('category_id', params.category)
    if (params.employment_type) query = query.eq('employment_type', params.employment_type)

    query = query.range(offset, offset + limit - 1)

    const { data, error, count } = await query

    if (error) {
      console.error('Error fetching job posts:', error)
      return { success: false, error: 'Failed to fetch job posts' }
    }

    return {
      success: true,
      data: {
        posts: (data as JobPostWithUsers[]) || [],
        total: count || 0,
        page,
        pages: Math.ceil((count || 0) / limit),
      },
    }
  } catch (error) {
    console.error('Unexpected error in getJobPostsAction:', error)
    return { success: false, error: 'An unexpected error occurred' }
  }
}

/**
 * Get single job post by ID
 */
export async function getJobPostByIdAction(id: string): Promise<ActionResponse<JobPostWithUsers>> {
  try {
    await verifySession()
    await requirePermission(Permissions.JOB_POSTS_VIEW)

    const supabase = await createClient()
    const { data, error } = await supabase
      .from('job_posts')
      .select(
        `
        *,
        category:job_categories(id, name),
        creator:created_by(name, email),
        updater:updated_by(name, email),
        publisher:published_by(name, email)
      `
      )
      .eq('id', id)
      .single()

    if (error) {
      console.error('Error fetching job post:', error)
      return { success: false, error: 'Job post not found' }
    }

    return { success: true, data: data as JobPostWithUsers }
  } catch (error) {
    console.error('Unexpected error in getJobPostByIdAction:', error)
    return { success: false, error: 'An unexpected error occurred' }
  }
}

/**
 * Create new job post
 */
export async function createJobPostAction(
  formData: JobPostFormData
): Promise<ActionResponse<JobPost>> {
  try {
    const user = await verifySession()
    await requirePermission(Permissions.JOB_POSTS_EDIT)

    const supabase = await createClient()

    // Get user email for application_email default
    const userEmail = user.email || user.user_metadata?.email || 'careers@myvirtualmate.com'
    const applicationEmail = formData.application_email?.trim() || userEmail

    // Validate email format
    if (!isValidEmail(applicationEmail)) {
      return { success: false, error: 'Valid application email is required' }
    }

    // Skills an array (for tags), split from multi-line text
    const skills = formData.skills ? splitByNewline(formData.skills) : []

    const insertData: Record<string, unknown> = {
      // job_id and slug auto-generated by trigger
      title: formData.title,
      overview: formData.overview || null,

      category_id: formData.category_id || null,
      department: formData.department || null,
      location: formData.location || null,
      employment_type: formData.employment_type,

      salary_min: formData.salary_min || null,
      salary_max: formData.salary_max || null,
      salary_currency: formData.salary_currency || 'AUD',
      salary_period: formData.salary_period || 'hourly',
      salary_custom_text: formData.salary_custom_text || null,

      // HTML content fields (from TipTap editor)
      responsibilities: formData.responsibilities || '',
      must_have_skills: formData.must_have_skills || '',
      preferred_skills: formData.preferred_skills || '',
      benefits: formData.benefits || '',
      // Skills array (for tags)
      skills,

      experience_level: formData.experience_level || null,
      status: formData.status || 'published',
      custom_posted_date: formData.custom_posted_date || null,

      application_email: applicationEmail,

      created_by: user.id,
      updated_by: user.id,
    }

    const { data, error } = await supabase
      .from('job_posts')
      .insert(insertData)
      .select('*, category:job_categories(id, name)')
      .single()

    if (error) {
      console.error('Error creating job post:', error)
      return { success: false, error: 'Failed to create job post' }
    }

    const jobPost = data as JobPost

    await createAuditLog({
      actorId: user.id,
      actionType: AUDIT_ACTION_TYPES.JOB_POST_CREATED,
      targetType: 'job_post',
      targetId: jobPost.id,
      metadata: { title: jobPost.title, job_id: jobPost.job_id, status: jobPost.status },
    })

    revalidatePath('/admin/job-posts/posts')

    return {
      success: true,
      data: jobPost,
      message: 'Job post created successfully',
    }
  } catch (error) {
    console.error('Unexpected error in createJobPostAction:', error)
    return { success: false, error: 'An unexpected error occurred' }
  }
}

/**
 * Update existing job post
 */
export async function updateJobPostAction(
  id: string,
  formData: JobPostFormData
): Promise<ActionResponse<JobPost>> {
  try {
    const user = await verifySession()
    await requirePermission(Permissions.JOB_POSTS_EDIT)

    const supabase = await createClient()

    const { data: existingPost, error: fetchError } = await supabase
      .from('job_posts')
      .select('*')
      .eq('id', id)
      .single()

    if (fetchError || !existingPost) {
      return { success: false, error: 'Job post not found' }
    }

    // Validate application email if provided
    const applicationEmail = formData.application_email?.trim()
    if (applicationEmail && !isValidEmail(applicationEmail)) {
      return { success: false, error: 'Valid application email is required' }
    }

    // Skills is still an array (for tags), split from multi-line text
    const skills = formData.skills ? splitByNewline(formData.skills) : []

    const updateData: Record<string, unknown> = {
      title: formData.title,
      overview: formData.overview || null,

      category_id: formData.category_id || null,
      department: formData.department || null,
      location: formData.location || null,
      employment_type: formData.employment_type,

      salary_min: formData.salary_min || null,
      salary_max: formData.salary_max || null,
      salary_currency: formData.salary_currency || 'AUD',
      salary_period: formData.salary_period || 'hourly',
      salary_custom_text: formData.salary_custom_text || null,

      // HTML content fields (from TipTap editor)
      responsibilities: formData.responsibilities || '',
      must_have_skills: formData.must_have_skills || '',
      preferred_skills: formData.preferred_skills || '',
      benefits: formData.benefits || '',
      // Skills array (for tags)
      skills,

      experience_level: formData.experience_level || null,
      status: formData.status || existingPost.status,
      custom_posted_date: formData.custom_posted_date || null,

      ...(applicationEmail && { application_email: applicationEmail }),

      updated_by: user.id,
    }

    const { data, error } = await supabase
      .from('job_posts')
      .update(updateData)
      .eq('id', id)
      .select('*, category:job_categories(id, name)')
      .single()

    if (error) {
      console.error('Error updating job post:', error)
      return { success: false, error: 'Failed to update job post' }
    }

    const jobPost = data as JobPost

    await createAuditLog({
      actorId: user.id,
      actionType: AUDIT_ACTION_TYPES.JOB_POST_UPDATED,
      targetType: 'job_post',
      targetId: id,
      metadata: { title: jobPost.title, job_id: jobPost.job_id, changes: Object.keys(updateData) },
    })

    revalidatePath('/admin/job-posts/posts')
    revalidatePath(`/admin/job-posts/posts/${id}`)

    return {
      success: true,
      data: jobPost,
      message: 'Job post updated successfully',
    }
  } catch (error) {
    console.error('Unexpected error in updateJobPostAction:', error)
    return { success: false, error: 'An unexpected error occurred' }
  }
}

/**
 * Publish job post
 */
export async function publishJobPostAction(id: string): Promise<ActionResponse<JobPost>> {
  try {
    const user = await verifySession()
    await requirePermission(Permissions.JOB_POSTS_PUBLISH)

    const supabase = await createClient()

    const { data: post, error: fetchError } = await supabase
      .from('job_posts')
      .select('*')
      .eq('id', id)
      .single()

    if (fetchError || !post) {
      return { success: false, error: 'Job post not found' }
    }

    const validation = canPublishPost(post)
    if (!validation.valid) {
      return {
        success: false,
        error: `Cannot publish: ${validation.errors.join(', ')}`,
      }
    }

    const { data, error } = await supabase
      .from('job_posts')
      .update({ status: 'published', published_by: user.id, published_at: new Date() })
      .eq('id', id)
      .select('*, category:job_categories(id, name)')
      .single()

    if (error) {
      console.error('Error publishing job post:', error)
      return { success: false, error: 'Failed to publish job post' }
    }

    await createAuditLog({
      actorId: user.id,
      actionType: AUDIT_ACTION_TYPES.JOB_POST_PUBLISHED,
      targetType: 'job_post',
      targetId: id,
      metadata: { title: post.title },
    })

    revalidatePath('/admin/job-posts/posts')

    return {
      success: true,
      data: data as JobPost,
      message: 'Job post published successfully',
    }
  } catch (error) {
    console.error('Unexpected error in publishJobPostAction:', error)
    return { success: false, error: 'An unexpected error occurred' }
  }
}

/**
 * Unpublish job post
 */
export async function unpublishJobPostAction(id: string): Promise<ActionResponse<JobPost>> {
  try {
    const user = await verifySession()
    await requirePermission(Permissions.JOB_POSTS_PUBLISH)

    const supabase = await createClient()

    const { data, error } = await supabase
      .from('job_posts')
      .update({
        status: 'unpublished',
        published_by: null,
      })
      .eq('id', id)
      .select('*, category:job_categories(id, name)')
      .single()

    if (error) {
      console.error('Error unpublishing job post:', error)
      return { success: false, error: 'Failed to unpublish job post' }
    }

    await createAuditLog({
      actorId: user.id,
      actionType: AUDIT_ACTION_TYPES.JOB_POST_UNPUBLISHED,
      targetType: 'job_post',
      targetId: id,
      metadata: { title: data.title },
    })

    revalidatePath('/admin/job-posts/posts')

    return {
      success: true,
      data: data as JobPost,
      message: 'Job post unpublished successfully',
    }
  } catch (error) {
    console.error('Unexpected error in unpublishJobPostAction:', error)
    return { success: false, error: 'An unexpected error occurred' }
  }
}

/**
 * Delete job post
 */
export async function deleteJobPostAction(id: string): Promise<ActionResponse<void>> {
  try {
    const user = await verifySession()
    await requirePermission(Permissions.JOB_POSTS_DELETE)

    const supabase = await createClient()

    const { data: post } = await supabase
      .from('job_posts')
      .select('title, status')
      .eq('id', id)
      .single()

    if (post?.status === 'published') {
      return {
        success: false,
        error: 'Cannot delete published job post. Unpublish it first.',
      }
    }

    const { error } = await supabase.from('job_posts').delete().eq('id', id)

    if (error) {
      console.error('Error deleting job post:', error)
      return { success: false, error: 'Failed to delete job post' }
    }

    await createAuditLog({
      actorId: user.id,
      actionType: AUDIT_ACTION_TYPES.JOB_POST_DELETED,
      targetType: 'job_post',
      targetId: id,
      metadata: { title: post?.title },
    })

    revalidatePath('/admin/job-posts/posts')

    return {
      success: true,
      data: undefined,
      message: 'Job post deleted successfully',
    }
  } catch (error) {
    console.error('Unexpected error in deleteJobPostAction:', error)
    return { success: false, error: 'An unexpected error occurred' }
  }
}
